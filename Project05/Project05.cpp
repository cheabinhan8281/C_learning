#include<stdio.h>

int main() {

	// 비트 연산자
	//10진수 <-> 2진수 <-> 16진수
	/*
	0: 0000 0000		00
	1: 0000 0001 v		01
	2: 0000 0010 v		02
	3: 0000 0011
	4: 0000 0100 v
	5: 0000 0101
	6: 0000 0110
	7: 0000 0111
	8: 0000 1000 v		08
	9: 0000 1001		09
	10:0000 1010		0A
	11:0000 1011		0B
	12:0000 1100		0C
	13:0000 1101		0D
	14:0000 1110		0E
	15: 0000 1111		0F
	# char(1byte, 8bit, -128~128, ) 마지막 비트 +- 부호
	# unsigned char()

	컴퓨터에서 음수를 표현(저장)하는 방법 -> 2의보수 사용
	0000 0000 : 0
	1111 1111 : -0 <- 생기지 않도록! 보수 개념도입

	0000 0010 -> 2 -> -2
	1111 1101 : 10진수 2의 각 자리 반전(1의보수)
	1111 1110 : 1을 더함 => -2

	0000 0001 : 1
	1111 1110 : 10진수 1의보수
	1111 1111 : -1




	*/


	char ch = -128; // 1000 0000 제일 앞에 부호 1, 나머지 0으로 128 표현
	printf("%02X\n", ch);	// 16진수

	char n1 = 5;	// 0101
	char n2 = 3;	// 0011
	char n3;
	n3 = n1 & n2;	// 0001
	printf("%d & %d = %d\n", n1, n2, n3);
	n3 = n1 | n2;	// 0111
	printf("%d | %d = %d\n", n1, n2, n3);
	n3 = n1 ^ n2;	// 0110
	printf("%d ^ %d = %d\n", n1, n2, n3);
	n3 = ~n1;	// 1010
	printf("~%d = %d\n", n1, n3);
	n3 = n1 << 2; //0001 0100 Left Shift 비트를 왼쪽으로 2비트만큼 이동
	printf("%d << 2 = %d\n", n1, n3);
	n3 = n1 >> 2; //0000 0001 Right Shift 비트를 오른쪽으로 2비트만큼 이동
	printf("%d >> 2 = %d\n", n1, n3);

	n1 = -128;		// 1000 0000
	n3 = n1 >> 1;	// 1100 0000	음수일 때 왼쪽으로 채워지는 값은 1이다
	printf("%d >> 1 = %02X\n", n1, n3);

	// 오른쪽으로 비트를 이동시킬때는 부호와 같은 값이 왼쪽으로부터 채워진다.



	return 0;
}